"""Solution of the Day 5 assignment."""
from __future__ import annotations
from os.path import join
import re
from dataclasses import dataclass

# conversions merging example
#
# Consider the following conversion chain
#
# (dst1, src1, rng1) -> (dst2, src2, rng2)
#
# when the intervals (dst1, dst1 + rng1) and (src2, src2 + rng2) are not equal but there is perhaps 
# some overlap, we can reduce the conversion. E.g. if src2 > dst1, the difference is 
# diff2 = src2 - dst1, the first conversion can be modified as (dst1 + diff2, src1 + diff2, rng1) 
# where rng1 should perhaps also be replaced by min(rng2, rng1 + diff2) so that the second interval 
# is not larger than the first one.

@dataclass
class IntegerInterval:
    start: int
    end: int

    def __post_init__(self: IntegerInterval):
        assert self.end >= self.start

    def __eq__(self: IntegerInterval, other: IntegerInterval):
        return self.start == other.start and self.end == other.end
    
    def is_subinterval(self: IntegerInterval, other: IntegerInterval):
        return other.start >= self.start and other.end <= self.end
    
    def __str__(self: IntegerInterval):
        return f"[{self.start} - {self.end}]"
    
    def __format__(self, __format_spec: str) -> str:
        return str(self)

def extract_integers(text: str) -> list[str]:
    """This function extracts list of integers from string. Each integer should be separated by
    space.

    Args:
        text (str): string of number repsenting characters, numbers separated by spaces

    Returns:
        list[str]: extracted numbers
    """
    return re.findall(r"\d+", text)


def key_to_key(key: int, ranges: list[tuple[int, ...]]) -> int:
    new_key: int = key
    for range_tuple in ranges:
        if key >= range_tuple[1] and key <= (range_tuple[1] + range_tuple[2]):
            return key - range_tuple[1] + range_tuple[0]
    return new_key


def divide_intervals(
    first: IntegerInterval, second: IntegerInterval
) -> list[IntegerInterval]:
    """Function creates list of subintervals generated by the intersection of two intervals. Only 
    such parts, that are subintervals if the first one are returned.

    Args:
        first (IntegerInterval): _description_
        second (IntegerInterval): _description_

    Returns:
        list[IntegerInterval]: _description_
    """
    # interval: [start, range]
    # 1. (A  (B   B)   A)
    if first.start <= second.start and first.end >= second.end:
        return [IntegerInterval(first.start, max(first.start, second.start-1)), IntegerInterval(second.start, second.end), IntegerInterval(min(second.end+1, first.end), first.end)]
    # 2. (A  (B   A)   B)
    elif first.start <= second.start and first.end <= second.end and first.end > second.start:
        return [IntegerInterval(first.start, max(first.start, second.start-1)), IntegerInterval(second.start, first.end)]
    # 3. (B  (A   B)   A)
    elif second.start <= first.start and second.end <= first.end and second.end > first.start:
        return [IntegerInterval(first.start, second.end), IntegerInterval(min(second.end+1, first.end), first.end)]
    # 4. (B  (A   A)   B)
    elif second.start <= first.start and first.end <= second.end:
        return [IntegerInterval(first.start, first.end)]
    # 5. (A   A)  (B   B)
    elif first.end < second.start:
        return [first]
    # 6. (B   B)  (A   A)
    elif second.end < first.start:
        return [first]
    else:
        return [first]


def range_to_range(
    input_range: tuple[int, int], conversion_ranges: list[tuple[int, int, int]]
) -> list[tuple[int, int]]:
    # start range
    # dst src range

    output_ranges: list[tuple[int, int]] = []

    for conversion_range in conversion_ranges:
        intersection_range = interval_intersection(
            input_range, (conversion_range[1], conversion_range[2])
        )
        if intersection_range:
            conversion_offset: int = conversion_range[0] - conversion_range[1]
            output_ranges.append((intersection_range[0] + conversion_offset, intersection_range[1]))
    return output_ranges

def merge_intervals(intervals: list[IntegerInterval]) -> list[IntegerInterval]:

    unique_intervals: list[IntegerInterval] = []

    for interval in intervals:
        is_subinterval: bool = False
        for unique_interval in unique_intervals:
            if unique_interval.is_subinterval(interval):
                is_subinterval = True
        if not is_subinterval:        
            unique_intervals.append(interval)

    return unique_intervals


def main(file_path: str) -> int:
    """Main function of the solution

    Args:
        file_path (str): _description_
    """

    seeds: list[int] = []
    map_name: str = ""
    map_almanach: dict[str, list[tuple[int, ...]]] = {}

    with open(file_path, "r", encoding="utf_8") as file:
        for line in file:
            if "seeds" in line:
                seeds_text: list[str] = line.split(":")
                seeds = [int(seed) for seed in extract_integers(seeds_text[1])]
            elif "map" in line:
                map_name = line.replace("map:", "").strip()
            elif line.strip():
                if map_name in map_almanach:
                    map_almanach[map_name].append(
                        tuple(int(number) for number in extract_integers(line))
                    )
                else:
                    map_almanach[map_name] = [
                        tuple(int(number) for number in extract_integers(line))
                    ]

    current_name: str = "seed"
    current_key: str = ""
    key_chain: dict[str, str] = {}
    key_list: list[str] = [key for key in map_almanach.keys()]
    ranges_chain: list[list[tuple[int, ...]]] = []
    done: bool = False
    next_key_found: bool = False

    while not done:
        for key in key_list:
            next_key_found = False
            name_list: list[str] = key.split("-to-")
            if current_name in name_list[0]:
                current_name = name_list[1]
                key_chain[current_key] = key
                ranges_chain.append(map_almanach[key])
                current_key = key
                next_key_found = True

        if not next_key_found:
            done = True

    # key_chain.pop("")

    # ranges: list[tuple[int, ...]] = map_almanach[key_list[0]]
    min_result: int = 2**50
    seed_ranges: list[tuple[int, int]] = [
        (seeds[i], seeds[i + 1]) for i in range(0, len(seeds), 2)
    ]
    current_key = ""
    done = False
    min_element: int = 2**50

    for seed_range in seed_ranges:
        seed_intervals = [IntegerInterval(seed_range[0], sum(seed_range)-1)]
        print("==================")
        print(f"seed interval: {seed_intervals}")

        for conversion_idx, conversion_element in enumerate(ranges_chain):
            converted_intervals = []
            for conversion_range in conversion_element:
                source_interval = IntegerInterval(conversion_range[1], conversion_range[1] + conversion_range[2] -1)
                dest_interval = IntegerInterval(conversion_range[0], conversion_range[0] + conversion_range[2] - 1)
                new_seed_intervals = []

                for seed_interval in seed_intervals:
                    tmp_seed_intervals = divide_intervals(seed_interval, source_interval)
                    valid_intervals = [True for _ in tmp_seed_intervals]

                    for division_idx, division_interval in enumerate(tmp_seed_intervals):
                        if source_interval.is_subinterval(division_interval):
                            offset: int = division_interval.start - source_interval.start
                            division_range: int = division_interval.end - division_interval.start
                            converted_intervals.append(IntegerInterval(dest_interval.start + offset, dest_interval.start + offset + division_range))
                            valid_intervals[division_idx] = False
                    
                    new_seed_intervals += [interval for interval_idx, interval in enumerate(tmp_seed_intervals) if valid_intervals[interval_idx]]

                seed_intervals = new_seed_intervals + converted_intervals
                seed_intervals = merge_intervals(seed_intervals)

            print(f"{key_list[conversion_idx]}: {seed_intervals}")
        
        min_element = min(min_element, *[interval.start for interval in seed_intervals])         

    return min_element


def test(test_file_path: str) -> bool:
    true_min_location: int = 46
    min_location: int = main(test_file_path)

    return true_min_location == min_location


if __name__ == "__main__":
    file_path: str = join(".", "Day_5", "input.txt")
    # file_path: str = join(".", "Day_5", "test.txt")

    print(main(file_path))
    # print(test(file_path))
